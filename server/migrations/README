from flask import request
from flask_restful import Resource
from flask_login import current_user, login_required
from sqlalchemy.exc import IntegrityError

# предполагаю что это уже есть:
# from config import db
# from models import User, Topic, TutorService, Request
# from schemas import (
#   users_public_schema, user_public_schema,
#   tutor_services_schema, tutor_service_schema,
#   requests_schema, request_schema
# )

# -------------------------
# Helpers (минимальные)
# -------------------------

def is_tutor():
    return current_user.is_authenticated and current_user.role == "tutor"

def is_student():
    return current_user.is_authenticated and current_user.role == "student"

# -------------------------
# Users
# -------------------------

class Users(Resource):
    def get(self):
        users = User.query.all()
        return users_public_schema.dump(users), 200


class UserById(Resource):
    def get(self, id):
        user = User.query.get(id)
        if not user:
            return {"error": "Not Found"}, 404
        return user_public_schema.dump(user), 200


class Tutors(Resource):
    def get(self):
        tutors = User.query.filter_by(role="tutor").all()
        return users_public_schema.dump(tutors), 200


class TutorById(Resource):
    def get(self, id):
        tutor = User.query.filter_by(id=id, role="tutor").first()
        if not tutor:
            return {"error": "Not Found"}, 404
        return user_public_schema.dump(tutor), 200

# -------------------------
# TutorService (tutor <-> topic)
# -------------------------

class TutorServices(Resource):
    def get(self):
        services = TutorService.query.all()
        return tutor_services_schema.dump(services), 200

    @login_required
    def post(self):
        if not is_tutor():
            return {"error": "Forbidden"}, 403

        data = request.get_json() or {}
        topic_id = data.get("topic_id")
        rate = data.get("rate")
        description = data.get("description")

        if not topic_id:
            return {"error": "topic_id is required"}, 400

        topic = Topic.query.get(topic_id)
        if not topic:
            return {"error": "Topic not found"}, 404

        service = TutorService(
            tutor_id=current_user.id,
            topic_id=topic_id,
            rate=rate,
            description=description
        )

        db.session.add(service)
        try:
            db.session.commit()
        except IntegrityError:
            db.session.rollback()
            return {"error": "Could not create tutor service"}, 400

        return tutor_service_schema.dump(service), 201


class TutorServiceById(Resource):
    def get(self, id):
        service = TutorService.query.get(id)
        if not service:
            return {"error": "Not Found"}, 404
        return tutor_service_schema.dump(service), 200

    @login_required
    def patch(self, id):
        service = TutorService.query.get(id)
        if not service:
            return {"error": "Not Found"}, 404

        if not is_tutor() or service.tutor_id != current_user.id:
            return {"error": "Forbidden"}, 403

        data = request.get_json() or {}

        if "rate" in data:
            service.rate = data["rate"]
        if "description" in data:
            service.description = data["description"]
        if "topic_id" in data:
            topic = Topic.query.get(data["topic_id"])
            if not topic:
                return {"error": "Topic not found"}, 404
            service.topic_id = data["topic_id"]

        db.session.add(service)
        db.session.commit()
        return tutor_service_schema.dump(service), 200

    @login_required
    def delete(self, id):
        service = TutorService.query.get(id)
        if not service:
            return {"error": "Not Found"}, 404

        if not is_tutor() or service.tutor_id != current_user.id:
            return {"error": "Forbidden"}, 403

        db.session.delete(service)
        db.session.commit()
        return {}, 204

# -------------------------
# Requests
# -------------------------

class Requests(Resource):
    def get(self):
        # Минимально: все. Если хочешь “только мои” — скажи, сделаю фильтр.
        reqs = Request.query.all()
        return requests_schema.dump(reqs), 200

    @login_required
    def post(self):
        if not is_student():
            return {"error": "Forbidden"}, 403

        data = request.get_json() or {}
        tutor_id = data.get("tutor_id")
        topic_id = data.get("topic_id")
        description = data.get("description")

        if not tutor_id or not topic_id:
            return {"error": "tutor_id and topic_id are required"}, 400

        tutor = User.query.filter_by(id=tutor_id, role="tutor").first()
        if not tutor:
            return {"error": "Tutor not found"}, 404

        topic = Topic.query.get(topic_id)
        if not topic:
            return {"error": "Topic not found"}, 404

        req = Request(
            status="pending",
            description=description,
            student_id=current_user.id,
            tutor_id=tutor_id,
            topic_id=topic_id
        )

        db.session.add(req)
        db.session.commit()
        return request_schema.dump(req), 201


class RequestById(Resource):
    def get(self, id):
        req = Request.query.get(id)
        if not req:
            return {"error": "Not Found"}, 404
        return request_schema.dump(req), 200

    @login_required
    def patch(self, id):
        req = Request.query.get(id)
        if not req:
            return {"error": "Not Found"}, 404

        data = request.get_json() or {}

        # Минимальная логика прав:
        # - tutor может менять status у своих requests
        # - student может менять только description у своих pending
        if is_tutor() and req.tutor_id == current_user.id:
            if "status" in data:
                if data["status"] not in ("pending", "accepted", "rejected", "completed"):
                    return {"error": "Invalid status"}, 400
                req.status = data["status"]
            if "description" in data:
                req.description = data["description"]

        elif is_student() and req.student_id == current_user.id:
            if req.status != "pending":
                return {"error": "Forbidden"}, 403
            if "description" in data:
                req.description = data["description"]
            if "status" in data:
                return {"error": "Student cannot change status"}, 403
        else:
            return {"error": "Forbidden"}, 403

        db.session.add(req)
        db.session.commit()
        return request_schema.dump(req), 200

    @login_required
    def delete(self, id):
        req = Request.query.get(id)
        if not req:
            return {"error": "Not Found"}, 404

        # Минимально: student может удалить только свой pending
        if not (is_student() and req.student_id == current_user.id and req.status == "pending"):
            return {"error": "Forbidden"}, 403

        db.session.delete(req)
        db.session.commit()
        return {}, 204

# -------------------------
# Register resources
# -------------------------
# Добавь это рядом с твоими api.add_resource(...)
# api.add_resource(Users, "/users")
# api.add_resource(UserById, "/users/<int:id>")
# api.add_resource(Tutors, "/tutors")
# api.add_resource(TutorById, "/tutors/<int:id>")
# api.add_resource(TutorServices, "/tutor_services")
# api.add_resource(TutorServiceById, "/tutor_services/<int:id>")
# api.add_resource(Requests, "/requests")
# api.add_resource(RequestById, "/requests/<int:id>")















# server/schemas.py

from marshmallow import fields
from config import ma
from models import User, Topic, TutorService, Request


# -------------------------
# Pablic schemas 
# -------------------------

class UserPublicSchema(ma.SQLAlchemyAutoSchema):
    class Meta:
        model = User
        load_instance = True
        include_fk = True
        fields = ("id", "name", "role")


class TopicMiniSchema(ma.SQLAlchemyAutoSchema):
    class Meta:
        model = Topic
        load_instance = True
        include_fk = True
        fields = ("id", "topic", "description")


# -------------------------
# TutorService schemas
# -------------------------

class TutorServiceWithTutorSchema(ma.SQLAlchemyAutoSchema):
    # For Topic detail pages: show tutor info + rate/description
    tutor = fields.Nested(UserPublicSchema)

    class Meta:
        model = TutorService
        load_instance = True
        include_fk = True
        include_relationships = False
        fields = ("id", "rate", "description", "tutor_id", "topic_id", "tutor")


class TutorServiceWithTopicSchema(ma.SQLAlchemyAutoSchema):
    # For Tutor profile pages: show topic info + rate/description
    topic = fields.Nested(TopicMiniSchema)

    class Meta:
        model = TutorService
        load_instance = True
        include_fk = True
        include_relationships = False
        fields = ("id", "rate", "description", "tutor_id", "topic_id", "topic")


class TutorServiceSchema(ma.SQLAlchemyAutoSchema):
    # Full-ish: includes both nested tutor and topic (still safe, because both are "mini")
    tutor = fields.Nested(UserPublicSchema)
    topic = fields.Nested(TopicMiniSchema)

    class Meta:
        model = TutorService
        load_instance = True
        include_fk = True
        include_relationships = False
        fields = ("id", "rate", "description", "tutor_id", "topic_id", "tutor", "topic")


# -------------------------
# Request schema
# -------------------------

class RequestSchema(ma.SQLAlchemyAutoSchema):
    student = fields.Nested(UserPublicSchema)
    tutor = fields.Nested(UserPublicSchema)
    topic = fields.Nested(TopicMiniSchema)

    class Meta:
        model = Request
        load_instance = True
        include_fk = True
        include_relationships = False
        fields = (
            "id",
            "status",
            "description",
            "student_id",
            "tutor_id",
            "topic_id",
            "student",
            "tutor",
            "topic",
        )


# -------------------------
# Topic schema
# -------------------------

class TopicSchema(ma.SQLAlchemyAutoSchema):
    # Expose tutor_services with nested tutor (good for "Topic detail")
    tutor_services = fields.List(fields.Nested(TutorServiceWithTutorSchema))

    class Meta:
        model = Topic
        load_instance = True
        include_fk = True
        include_relationships = False
        fields = ("id", "topic", "description", "tutor_services")


# -------------------------
# User schema
# -------------------------

class UserSchema(ma.SQLAlchemyAutoSchema):
    # Tutor view: what they teach (topic nested)
    tutor_services = fields.List(fields.Nested(TutorServiceWithTopicSchema))

    # Student/tutor requests
    sent_requests = fields.List(fields.Nested(RequestSchema))
    received_requests = fields.List(fields.Nested(RequestSchema))

    class Meta:
        model = User
        load_instance = True
        include_fk = True
        include_relationships = False
        # password is intentionally NOT included
        fields = (
            "id",
            "name",
            "role",
            "tutor_services",
            "sent_requests",
            "received_requests",
        )


# -------------------------
# Instances
# -------------------------

user_schema = UserSchema()
users_schema = UserSchema(many=True)

user_public_schema = UserPublicSchema()
users_public_schema = UserPublicSchema(many=True)

topic_schema = TopicSchema()
topics_schema = TopicSchema(many=True)

topic_mini_schema = TopicMiniSchema()
topics_mini_schema = TopicMiniSchema(many=True)

tutor_service_schema = TutorServiceSchema()
tutor_services_schema = TutorServiceSchema(many=True)

request_schema = RequestSchema()
requests_schema = RequestSchema(many=True)














# server/schemas.py

from marshmallow import fields
from config import ma
from models import User, Topic, TutorService, Request

# --- minimal public user (safe to nest) ---
class UserPublicSchema(ma.SQLAlchemyAutoSchema):
    class Meta:
        model = User
        load_instance = True
        fields = ("id", "name", "role")

# --- tutor service nested under topic (includes tutor) ---
class TutorServiceInTopicSchema(ma.SQLAlchemyAutoSchema):
    tutor = fields.Nested(UserPublicSchema)

    class Meta:
        model = TutorService
        load_instance = True
        include_fk = True
        include_relationships = False
        fields = ("id", "rate", "description", "tutor_id", "topic_id", "tutor")

# --- request nested under topic (includes tutor; no nested topic to avoid recursion) ---
class RequestInTopicSchema(ma.SQLAlchemyAutoSchema):
    tutor = fields.Nested(UserPublicSchema)

    class Meta:
        model = Request
        load_instance = True
        include_fk = True
        include_relationships = False
        fields = (
            "id",
            "status",
            "description",
            "student_id",
            "tutor_id",
            "topic_id",
            "tutor",
        )

# --- topic nested under user for login payload ---
class TopicInUserSchema(ma.SQLAlchemyAutoSchema):
    tutor_services = fields.List(fields.Nested(TutorServiceInTopicSchema))
    requests = fields.List(fields.Nested(RequestInTopicSchema))

    class Meta:
        model = Topic
        load_instance = True
        include_fk = True
        include_relationships = False
        fields = ("id", "topic", "description", "tutor_services", "requests")

# --- LOGIN / CHECK_SESSION payload ---
class AuthUserSchema(ma.SQLAlchemyAutoSchema):
    topics = fields.List(fields.Nested(TopicInUserSchema))

    class Meta:
        model = User
        load_instance = True
        include_fk = True
        include_relationships = False
        fields = ("id", "name", "role", "topics")

auth_user_schema = AuthUserSchema()